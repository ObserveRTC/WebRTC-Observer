Observer Documentation
===

This document is written for version [hydrogen](https://github.com/ObserveRTC/observer/releases/tag/hydrogen)

![hydrogen](hydrogen.png)

# Introduction

WebRTC-Observer is a microservice written in Java to collect and analyze 
measurements originated by WebRTC Applications. It is designed to be a 
monitoring solution for WebRTC Applications scalable 
from a single, local development up to a large kubernetes cluster.  


# Architecture

![Architecture](architecture.png)

In our architectural model, the observer takes place as a 
processing element, capable of accepting samples from the 
collecting components, and can forward reports to a Data Sink.

You can read a detailed description about the architecture 
in our [main](http://observertc.org) page.

The service is written in Java, using [micronaut](https://micronaut.io) 
framework to implement the observer business logic, 
and [hazelcast](https://hazelcast.org) in-memory-data-grid is used 
to share data between service components, and instances.


# Application Programming Interfaces (API)

The observer is responsible to provide interfaces for the following operations:

* Accept samples
* Provide metrics
* Forward reports

## Accept Samples

THe service can listen for samples on various 
inputs (e.g. websocket server), and samples are accepted if 
the invoked input validate the provided samples.

The service accepts samples provided by the following schemas:
 * [Peer Connection Samples](###peer-connection-sample)


### Peer Connection Sample

The peer connection sample multiplexes 
webrtc stats metrics, client details, and user media informations.

Clients providing Peer Connection Samples: 
 * [observer-js](https://github.com/ObserveRTC/observer-js)

#### Version: 20200114

 * [Schema description](pcsample-v20200114.md)
 * [Json Schema]()


### Sample Listeners

#### Websockets

Schema: [Peer Connection Sample](#peer-connection-sample) **Version**: 20200114:
 * ws(s)://{HOST}:{PORT}/{serviceUUID}/{mediaUnitId}/v20200114/json

## Provided Metrics

The observer monitors the incoming samples and expose metrics.
The metrics are exposed using [micrometer](https://micrometer.io/) plugin in
[micronaut](https://micronaut-projects.github.io/micronaut-micrometer/latest/guide/index.html#introduction)
framework.

### Integrations


All integration with the supported
metrics' server is possible via a proper micronaut configuration, which
is part of the observer (or observer part of micronaut it is a matter
of perspective).

The default integration this version is compiled is the [prometheus](https://micronaut-projects.github.io/micronaut-micrometer/latest/guide/index.html#prometheus)
integration.

### General Metrics

|          Metric Name         |   Type  |                                                  Description                                                  |          Tags          |
|:----------------------------:|:-------:|:-------------------------------------------------------------------------------------------------------------:|:----------------------:|
| observertc_opened_websockets | Counter | Indicates the number of opened websocket                                                                      |  -                     |
| observertc_closed_websockets | Counter | Indicates the number of closed websocket                                                                      |  -                     |
| observertc_pcsamples         | Counter | Indicates the number of peer connection samples received by the service                                       | mediaUnit, serviceName |
| observertc_generated_reports | Counter | Indicates the number of WebRTC-Reports generated by the service from the incoming samples                     | serviceName[^1]        |
| observertc_user_media_errors | Counter | Indicates the number of user media errors reported by the samples                                             | serviceName[^2]        |
| observertc_initiated_calls   | Counter | Indicates the number of calls identified and initiated by the observer                                        | service, mediaunit     |
| observertc_finished_calls    | Counter | Indicates the number of calls identified and finished by the observer                                         | service, mediaunit     |
| observertc_joined_pcs        | Counter | Indicates the number of peer connections joined to the observer                                               | service, mediaunit     |
| observertc_detached_pcs      | Counter | Indicates the number of peer connections detached from the observer                                           | service, mediaunit     |
| observertc_impairable_pcs    | Counter | Indicates the number of peer connections the observer skips to join to any call due to missing its parameters | service, mediaunit     |
| Flaws_monitor                | Counter | Indicates the number of errors reported by various part of the system.                                        | klass                  |

[^1]: configuration can extended it with serviceUUID, and reportType tags.
[^2]: configuration can extended it with serviceUUID tag.

### Sentinel Metrics


### Integrations





# Services

## Mappings

# Metrics

## Sentinels

## Collection Filtering

## Call Filters

## Peer Connection Filters


# Security

## Authentication

## Obfuscation

# Deployment

## Kubernetes

## Docker



# Reference Configuration

The following configuration serves as a reference configuration
for this version in `yaml` format with comments
explaining (more or less) what that configuration is intended
to setup.

The configuration must be parsed by the service engine framework
([micronaut](https://micronaut.io)), thus it should be placed
one of the config file it loads (e.g.: `application.yaml`).

```yaml
observer:
  
  # Setup security configuration specific to the observer service
  security:
    # Drop Peer Connection Samples, for which the service uuid does not match any service name
    dropUnknownServices: False
  
  # Sets up the mapping between service UUID and service Name.
  servicemappings:
    - name: "example-service-name"
      uuids:
        - "aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee"

  # if enabled the generated reports from the observer 
  # are monitored and the metrics are exposed.
  reportMonitor:
    enabled: true
    tagByServiceName: true
    tagByServiceUUID: false
    tagByType: false

  # if enabled the incoming user media errors are monitored  
  # and the metrics are exposed.
  userMediaErrorsMonitor:
    enabled: true
    tagByServiceName: true
    tagByServiceUUID: false
  
  # if enabled IP addresses are obfuscated
  ipAddressConverter:
    enabled: False
    algorithm: SHA-256
    salt: "MySalt"

  # If enabled the observer monitors inbound RTP traffic, 
  # and through sentinels it exposes metrics (received bytes, 
  # lost packets, etc.)
  # 
  inboundRtpMonitor:
    enabled: False
    retentionTimeInS: 300

  # If enabled the observer monitors remote inbound RTP traffic, 
  # and through sentinels it exposes metrics (RTT, etc.)
  # 
  remoteInboundRtpMonitor:
    enabled: True
    retentionTimeInS: 300
    weightFactor: 0.3

  # If enabled the observer monitors outbound RTP traffic, 
  # and through sentinels it exposes metrics (sent bytes, 
  # sent packets, etc.)
  # 
  # NOTE: this increase memory storage consumption and 
  # hazelcast traffic
  outboundRtpMonitor:
    enabled: True
    retentionTimeInS: 300  

  # Sets a filter for peer connections
  pcFilters:
    - name: "MyTurnServerFilter"
      remoteIPs:
        anyMatch: 
          - "10.10.10.10"
          - "20.20.20.20"
  
  # Add a call filter for peer to peer calls
  callFilters:
    - name: "MyPeerToPeerFilter"
      browserIds:
        eq: 2 
  
  # Configure a sentinel for your turn servers used by peer to peer calls
  # and expose metrics
  sentinels:
    - name: "MySentinel"
      expose: true 
      callFilters:
        allMatch: 
          - "MyPeerToPeerFilter"
      pcFilters:
        allMatch:
          - "MyTurnServerFilter"
  
  
  # The time Period sentinels are checking calls in minutes
  sentinelsCheckingPeriodInMin: 1
  
  
  # Defines the configuration for a connector the reports are sent to
  connectors:
    - name: "ReportSinkLogger"
      buffer:
        maxItems: 100
        maxWaitingTimeInS: 10
      sink:
        type: LoggerSink
        config:
          printReports: False

  # Sets up the Evaluators every incoming sample is subjected
  evaluators:
    
    # name of the calls, which cannot be paired (nor SSRC, neither call name was provided to match)
    impairablePCsCallName: "impairable-peer-connections-default-call-name"
    
    # The incoming sample buffer maximum waiting time before emission
    observedPCSBufferMaxTimeInS: 10
    
    # The incoming sample buffer maximum amount of items it can hold
    observedPCSBufferMaxItemNums: 10000
    
    # The maximum idle time for a peer connection before it is declared to be detached.
    peerConnectionMaxIdleTimeInS: 60
  
  # Sets up which type of webrtc reports the service can forward
  outboundReports:
    reportOutboundRTPs: True
    reportInboundRTPs: True
    reportRemoteInboundRTPs: True
    reportTracks: True
    reportMediaSources: True
    reportCandidatePairs: True
    reportLocalCandidates: True
    reportRemoteCandidates: True
    reportUserMediaErrors: True
    
  # Sets up the hazelcast configuration file
  hazelcast:
    configFile: ${HAZELCAST_CONFIG_FILE:`classpath:hazelcast.yaml`}
```

# Known Limitations

The following limitations are known to this version


# Implementation Details

## Evaluator Pipeline

The inner pipeline of the service is described in the `Pipeline` class.

### Input format

The Pipeline accepted input format is `ObservedPCS` object.


# Contributors

* [Balazs Kreith](https://github.com/balazskreith)
* [Pallab Gain](https://github.com/pallab-gain)

# Licenses

